/* tslint:disable */
/* eslint-disable */
/**
 * ShellHub Cloud
 * ShellHub Cloud documentation.  It documents all routes provided by ShellHub Cloud.   NOTICE: THE API IS NOT STABLE YET; ERROR AND INCONSISTENCIES MAY OCCUR. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: contato@ossystems.com.br
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddNamespaceMemberRequest
 */
export interface AddNamespaceMemberRequest {
    /**
     * Member\'s username.
     * @type {string}
     * @memberof AddNamespaceMemberRequest
     */
    'username': string;
    /**
     * 
     * @type {NamespaceMemberRole}
     * @memberof AddNamespaceMemberRequest
     */
    'role': NamespaceMemberRole;
}
/**
 * 
 * @export
 * @interface AddPaymentMethod200Response
 */
export interface AddPaymentMethod200Response {
    /**
     * Payment method\'s ID.
     * @type {string}
     * @memberof AddPaymentMethod200Response
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface AddTagPublicKeyRequest
 */
export interface AddTagPublicKeyRequest {
    /**
     * Tag\'s name.
     * @type {string}
     * @memberof AddTagPublicKeyRequest
     */
    'tag': string;
}
/**
 * Announcement.
 * @export
 * @interface Announcement
 */
export interface Announcement {
    /**
     * Announcement UUID.
     * @type {string}
     * @memberof Announcement
     */
    'uuid'?: string;
    /**
     * Announcement title.
     * @type {string}
     * @memberof Announcement
     */
    'title'?: string;
    /**
     * Announcement description.
     * @type {string}
     * @memberof Announcement
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof Announcement
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface AnnouncementShort
 */
export interface AnnouncementShort {
    /**
     * Announcement UUID.
     * @type {string}
     * @memberof AnnouncementShort
     */
    'uuid'?: string;
    /**
     * Announcement title.
     * @type {string}
     * @memberof AnnouncementShort
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnouncementShort
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface ChoiceDevicesRequest
 */
export interface ChoiceDevicesRequest {
    /**
     * Device\'s list.
     * @type {Array<string>}
     * @memberof ChoiceDevicesRequest
     */
    'choices': Array<string>;
}
/**
 * 
 * @export
 * @interface ClsoeSessionRequest
 */
export interface ClsoeSessionRequest {
    /**
     * Device\'s UID
     * @type {string}
     * @memberof ClsoeSessionRequest
     */
    'device': string;
}
/**
 * 
 * @export
 * @interface CreateDeviceTagRequest
 */
export interface CreateDeviceTagRequest {
    /**
     * Tag\'s name.
     * @type {string}
     * @memberof CreateDeviceTagRequest
     */
    'tag': string;
}
/**
 * 
 * @export
 * @interface CreateNamespaceRequest
 */
export interface CreateNamespaceRequest {
    /**
     * Namespace\'s name
     * @type {string}
     * @memberof CreateNamespaceRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreatePublicKey200Response
 */
export interface CreatePublicKey200Response {
    /**
     * Public key\'s data.  The `data` field receives the public key enconded as `base64` string. 
     * @type {string}
     * @memberof CreatePublicKey200Response
     */
    'data'?: string;
    /**
     * Public key\'s fingerprint.
     * @type {string}
     * @memberof CreatePublicKey200Response
     */
    'fingerprint'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof CreatePublicKey200Response
     */
    'tenant_id'?: string;
    /**
     * Public key\'s name.
     * @type {string}
     * @memberof CreatePublicKey200Response
     */
    'name'?: string;
    /**
     * 
     * @type {PublicKeyFilter}
     * @memberof CreatePublicKey200Response
     */
    'filter'?: PublicKeyFilter;
    /**
     * Public key\'s regex username.   The `username` field define which user, in the device, may be access through this public key. 
     * @type {string}
     * @memberof CreatePublicKey200Response
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface CreateSubscription200Response
 */
export interface CreateSubscription200Response {
    /**
     * Subscription\'s ID.
     * @type {string}
     * @memberof CreateSubscription200Response
     */
    'id'?: string;
    /**
     * Subscription\'s status.
     * @type {string}
     * @memberof CreateSubscription200Response
     */
    'status'?: string;
    /**
     * Subscription\'s cureency period end.
     * @type {string}
     * @memberof CreateSubscription200Response
     */
    'currency_period_end'?: string;
    /**
     * 
     * @type {CreateSubscription200ResponseCustomer}
     * @memberof CreateSubscription200Response
     */
    'customer'?: CreateSubscription200ResponseCustomer;
    /**
     * Payment method\'s ID.
     * @type {string}
     * @memberof CreateSubscription200Response
     */
    'payment_method_id'?: string;
}
/**
 * Subscription\'s customer.
 * @export
 * @interface CreateSubscription200ResponseCustomer
 */
export interface CreateSubscription200ResponseCustomer {
    /**
     * Customer\'s ID.
     * @type {string}
     * @memberof CreateSubscription200ResponseCustomer
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface CreateSubscriptionRequest
 */
export interface CreateSubscriptionRequest {
    /**
     * Payment method ID.
     * @type {string}
     * @memberof CreateSubscriptionRequest
     */
    'payment_method_id': string;
}
/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * Device\'s UID
     * @type {string}
     * @memberof Device
     */
    'uid'?: string;
    /**
     * Device\'s name   By default, the name is the device\'s MAC address when it just added. 
     * @type {string}
     * @memberof Device
     */
    'name'?: string;
    /**
     * 
     * @type {DeviceIdentity}
     * @memberof Device
     */
    'identity'?: DeviceIdentity;
    /**
     * 
     * @type {DeviceInfo}
     * @memberof Device
     */
    'info'?: DeviceInfo;
    /**
     * Device\'s public key.
     * @type {string}
     * @memberof Device
     */
    'public_key'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof Device
     */
    'tenant_id'?: string;
    /**
     * Device\'s last seen date
     * @type {string}
     * @memberof Device
     */
    'last_seen'?: string;
    /**
     * Device\'s availability status
     * @type {boolean}
     * @memberof Device
     */
    'online'?: boolean;
    /**
     * Namespace\'s name
     * @type {string}
     * @memberof Device
     */
    'namespace'?: string;
    /**
     * 
     * @type {DeviceStatus}
     * @memberof Device
     */
    'status'?: DeviceStatus;
    /**
     * Device\'s creation date
     * @type {string}
     * @memberof Device
     */
    'created_at'?: string;
    /**
     * Device\'s remote address
     * @type {string}
     * @memberof Device
     */
    'remote_addr'?: string;
    /**
     * 
     * @type {DevicePosition}
     * @memberof Device
     */
    'position'?: DevicePosition;
    /**
     * Device\'s Tags list
     * @type {Array<string>}
     * @memberof Device
     */
    'tags'?: Array<string>;
}
/**
 * Device\'s identity
 * @export
 * @interface DeviceIdentity
 */
export interface DeviceIdentity {
    /**
     * Device\'s MAC
     * @type {string}
     * @memberof DeviceIdentity
     */
    'mac'?: string;
}
/**
 * Device\'s info
 * @export
 * @interface DeviceInfo
 */
export interface DeviceInfo {
    /**
     * Device\'s OS name
     * @type {string}
     * @memberof DeviceInfo
     */
    'id'?: string;
    /**
     * Device\'s OS pretty name
     * @type {string}
     * @memberof DeviceInfo
     */
    'pretty_name'?: string;
    /**
     * Device\'s OS version
     * @type {string}
     * @memberof DeviceInfo
     */
    'version'?: string;
    /**
     * Device\'s OS arch
     * @type {string}
     * @memberof DeviceInfo
     */
    'arch'?: string;
    /**
     * Device\'s OS platform
     * @type {string}
     * @memberof DeviceInfo
     */
    'platform'?: DeviceInfoPlatformEnum;
}

export const DeviceInfoPlatformEnum = {
    Docker: 'docker',
    Native: 'native'
} as const;

export type DeviceInfoPlatformEnum = typeof DeviceInfoPlatformEnum[keyof typeof DeviceInfoPlatformEnum];

/**
 * Device\'s geolocation position
 * @export
 * @interface DevicePosition
 */
export interface DevicePosition {
    /**
     * Device\'s latitude position
     * @type {number}
     * @memberof DevicePosition
     */
    'latitude'?: number;
    /**
     * Device\'s longitude position
     * @type {number}
     * @memberof DevicePosition
     */
    'longitude'?: number;
}
/**
 * Device\'s status
 * @export
 * @enum {string}
 */

export const DeviceStatus = {
    Accepted: 'accepted',
    Rejected: 'rejected',
    Pending: 'pending',
    Unused: 'unused'
} as const;

export type DeviceStatus = typeof DeviceStatus[keyof typeof DeviceStatus];


/**
 * 
 * @export
 * @interface FirewallRulesRequest
 */
export interface FirewallRulesRequest {
    /**
     * Firewall rule\'s action
     * @type {string}
     * @memberof FirewallRulesRequest
     */
    'action': FirewallRulesRequestActionEnum;
    /**
     * Firewall rule active\'s status
     * @type {boolean}
     * @memberof FirewallRulesRequest
     */
    'active': boolean;
    /**
     * 
     * @type {FirewallRulesResponseFilter}
     * @memberof FirewallRulesRequest
     */
    'filter': FirewallRulesResponseFilter;
    /**
     * Firewall rule\'s priority
     * @type {number}
     * @memberof FirewallRulesRequest
     */
    'priority': number;
    /**
     * Firewall rule\'s source IP regexp
     * @type {string}
     * @memberof FirewallRulesRequest
     */
    'source_ip': string;
    /**
     * Firewall rule\'s username regexp
     * @type {string}
     * @memberof FirewallRulesRequest
     */
    'username': string;
}

export const FirewallRulesRequestActionEnum = {
    Allow: 'allow',
    Deny: 'deny'
} as const;

export type FirewallRulesRequestActionEnum = typeof FirewallRulesRequestActionEnum[keyof typeof FirewallRulesRequestActionEnum];

/**
 * 
 * @export
 * @interface FirewallRulesResponse
 */
export interface FirewallRulesResponse {
    /**
     * Firewall rule\'s ID.
     * @type {string}
     * @memberof FirewallRulesResponse
     */
    'id'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof FirewallRulesResponse
     */
    'tenant_id': string;
    /**
     * Firewall rule\'s action
     * @type {string}
     * @memberof FirewallRulesResponse
     */
    'action': FirewallRulesResponseActionEnum;
    /**
     * Firewall rule active\'s status
     * @type {boolean}
     * @memberof FirewallRulesResponse
     */
    'active': boolean;
    /**
     * 
     * @type {FirewallRulesResponseFilter}
     * @memberof FirewallRulesResponse
     */
    'filter': FirewallRulesResponseFilter;
    /**
     * Firewall rule\'s priority
     * @type {number}
     * @memberof FirewallRulesResponse
     */
    'priority': number;
    /**
     * Firewall rule\'s source IP regexp
     * @type {string}
     * @memberof FirewallRulesResponse
     */
    'source_ip': string;
    /**
     * Firewall rule\'s username regexp
     * @type {string}
     * @memberof FirewallRulesResponse
     */
    'username': string;
}

export const FirewallRulesResponseActionEnum = {
    Allow: 'allow',
    Deny: 'deny'
} as const;

export type FirewallRulesResponseActionEnum = typeof FirewallRulesResponseActionEnum[keyof typeof FirewallRulesResponseActionEnum];

/**
 * @type FirewallRulesResponseFilter
 * Firewall rule\'s filter
 * @export
 */
export type FirewallRulesResponseFilter = FirewallRulesResponseFilterOneOf | FirewallRulesResponseFilterOneOf1;

/**
 * 
 * @export
 * @interface FirewallRulesResponseFilterOneOf
 */
export interface FirewallRulesResponseFilterOneOf {
    /**
     * Firewall rule\'s hostname
     * @type {string}
     * @memberof FirewallRulesResponseFilterOneOf
     */
    'hostname': string;
}
/**
 * 
 * @export
 * @interface FirewallRulesResponseFilterOneOf1
 */
export interface FirewallRulesResponseFilterOneOf1 {
    /**
     * Firewall\'s rule tags
     * @type {Array<string>}
     * @memberof FirewallRulesResponseFilterOneOf1
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface GetSessionData401Response
 */
export interface GetSessionData401Response {
    /**
     * Error message
     * @type {string}
     * @memberof GetSessionData401Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface GetSessionData500Response
 */
export interface GetSessionData500Response {
    /**
     * Error message.
     * @type {string}
     * @memberof GetSessionData500Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface GetStatusDevices200Response
 */
export interface GetStatusDevices200Response {
    /**
     * Number of registered devices
     * @type {number}
     * @memberof GetStatusDevices200Response
     */
    'registered_devices'?: number;
    /**
     * Number of online devices
     * @type {number}
     * @memberof GetStatusDevices200Response
     */
    'online_devices'?: number;
    /**
     * Number of pending devices
     * @type {number}
     * @memberof GetStatusDevices200Response
     */
    'pending_devices'?: number;
    /**
     * Number of rejected devices
     * @type {number}
     * @memberof GetStatusDevices200Response
     */
    'rejected_devices'?: number;
    /**
     * Active sessions
     * @type {number}
     * @memberof GetStatusDevices200Response
     */
    'active_sessions'?: number;
}
/**
 * 
 * @export
 * @interface GetSubscription200Response
 */
export interface GetSubscription200Response {
    /**
     * Invoice\'s list.
     * @type {Array<GetSubscription200ResponseInvoicesInner>}
     * @memberof GetSubscription200Response
     */
    'invoices'?: Array<GetSubscription200ResponseInvoicesInner>;
}
/**
 * 
 * @export
 * @interface GetSubscription200ResponseInvoicesInner
 */
export interface GetSubscription200ResponseInvoicesInner {
    /**
     * Invoice\'s paid.
     * @type {boolean}
     * @memberof GetSubscription200ResponseInvoicesInner
     */
    'paid'?: boolean;
    /**
     * Invoice\'s status.
     * @type {string}
     * @memberof GetSubscription200ResponseInvoicesInner
     */
    'status'?: string;
    /**
     * Invoice\'s amount due.
     * @type {string}
     * @memberof GetSubscription200ResponseInvoicesInner
     */
    'amount_due'?: string;
    /**
     * Invoice\'s due date.
     * @type {string}
     * @memberof GetSubscription200ResponseInvoicesInner
     */
    'due_date'?: string;
    /**
     * Invoice\'s PDF.
     * @type {string}
     * @memberof GetSubscription200ResponseInvoicesInner
     */
    'pdf'?: string;
    /**
     * Invoice\'s URL.
     * @type {string}
     * @memberof GetSubscription200ResponseInvoicesInner
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface Info
 */
export interface Info {
    /**
     * ShellHub instance version.
     * @type {string}
     * @memberof Info
     */
    'version'?: string;
    /**
     * 
     * @type {InfoEndpoints}
     * @memberof Info
     */
    'endpoints'?: InfoEndpoints;
}
/**
 * 
 * @export
 * @interface InfoEndpoints
 */
export interface InfoEndpoints {
    /**
     * SSH endpoint.
     * @type {string}
     * @memberof InfoEndpoints
     */
    'ssh'?: string;
    /**
     * API endpoint.
     * @type {string}
     * @memberof InfoEndpoints
     */
    'api'?: string;
}
/**
 * 
 * @export
 * @interface Login
 */
export interface Login {
    /**
     * Username
     * @type {string}
     * @memberof Login
     */
    'username': string;
    /**
     * Password
     * @type {string}
     * @memberof Login
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Namespace
 */
export interface Namespace {
    /**
     * Namespace\'s name
     * @type {string}
     * @memberof Namespace
     */
    'name'?: string;
    /**
     * User\'s ID.
     * @type {string}
     * @memberof Namespace
     */
    'owner'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof Namespace
     */
    'tenant_id'?: string;
    /**
     * Namespace\'s members
     * @type {Array<NamespaceMembersInner>}
     * @memberof Namespace
     */
    'members'?: Array<NamespaceMembersInner>;
    /**
     * 
     * @type {NamespaceSettings}
     * @memberof Namespace
     */
    'settings'?: NamespaceSettings;
    /**
     * Namespace\'s max device numbers
     * @type {number}
     * @memberof Namespace
     */
    'max_devices'?: number;
    /**
     * Namespace\'s total devices
     * @type {number}
     * @memberof Namespace
     */
    'device_count'?: number;
    /**
     * Namespace\'s creation date
     * @type {string}
     * @memberof Namespace
     */
    'created_at'?: string;
    /**
     * Namespace\'s billing
     * @type {object}
     * @memberof Namespace
     */
    'billing'?: object;
}
/**
 * Namespace\'s member role
 * @export
 * @enum {string}
 */

export const NamespaceMemberRole = {
    Administrator: 'administrator',
    Operator: 'operator',
    Observer: 'observer',
    Owner: 'owner'
} as const;

export type NamespaceMemberRole = typeof NamespaceMemberRole[keyof typeof NamespaceMemberRole];


/**
 * 
 * @export
 * @interface NamespaceMembersInner
 */
export interface NamespaceMembersInner {
    /**
     * User\'s ID.
     * @type {string}
     * @memberof NamespaceMembersInner
     */
    'id'?: string;
    /**
     * 
     * @type {NamespaceMemberRole}
     * @memberof NamespaceMembersInner
     */
    'role'?: NamespaceMemberRole;
}
/**
 * Namespace\'s settings
 * @export
 * @interface NamespaceSettings
 */
export interface NamespaceSettings {
    /**
     * Namespace\'s session record status
     * @type {boolean}
     * @memberof NamespaceSettings
     */
    'session_record'?: boolean;
}
/**
 * 
 * @export
 * @interface PostAuthDevice200Response
 */
export interface PostAuthDevice200Response {
    /**
     * Device\'s UID
     * @type {string}
     * @memberof PostAuthDevice200Response
     */
    'uid'?: string;
    /**
     * Device\'s token
     * @type {string}
     * @memberof PostAuthDevice200Response
     */
    'token'?: string;
    /**
     * Device\'s name   By default, the name is the device\'s MAC address when it just added. 
     * @type {string}
     * @memberof PostAuthDevice200Response
     */
    'name'?: string;
    /**
     * Device\'s namespace name
     * @type {string}
     * @memberof PostAuthDevice200Response
     */
    'namespace'?: string;
}
/**
 * 
 * @export
 * @interface PostAuthDeviceRequest
 */
export interface PostAuthDeviceRequest {
    /**
     * 
     * @type {DeviceInfo}
     * @memberof PostAuthDeviceRequest
     */
    'info': DeviceInfo;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostAuthDeviceRequest
     */
    'sessions'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PostAuthDeviceRequest
     */
    'hostname': string;
    /**
     * 
     * @type {DeviceIdentity}
     * @memberof PostAuthDeviceRequest
     */
    'identity'?: DeviceIdentity;
    /**
     * Device\'s public key.
     * @type {string}
     * @memberof PostAuthDeviceRequest
     */
    'public_key': string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof PostAuthDeviceRequest
     */
    'tenant_id': string;
}
/**
 * @type PublicKeyFilter
 * Public key\'s filter rule.   The `filter`` rule defines how if the public key is valid to a device.  - When `hostname` object is set, the public key will be used in a device what matches with hostname. - When `tags` object is set, it matches the device what contains at least one of that tags.  
 * @export
 */
export type PublicKeyFilter = PublicKeyFilterOneOf | PublicKeyFilterOneOf1;

/**
 * 
 * @export
 * @interface PublicKeyFilterOneOf
 */
export interface PublicKeyFilterOneOf {
    /**
     * Public key\'s regex hostname.
     * @type {string}
     * @memberof PublicKeyFilterOneOf
     */
    'hostname': string;
}
/**
 * 
 * @export
 * @interface PublicKeyFilterOneOf1
 */
export interface PublicKeyFilterOneOf1 {
    /**
     * Public key\'s tags.
     * @type {Set<string>}
     * @memberof PublicKeyFilterOneOf1
     */
    'tags': Set<string>;
}
/**
 * 
 * @export
 * @interface PublicKeyRequest
 */
export interface PublicKeyRequest {
    /**
     * Public key\'s data.  The `data` field receives the public key enconded as `base64` string. 
     * @type {string}
     * @memberof PublicKeyRequest
     */
    'data': string;
    /**
     * 
     * @type {PublicKeyFilter}
     * @memberof PublicKeyRequest
     */
    'filter': PublicKeyFilter;
    /**
     * Public key\'s name.
     * @type {string}
     * @memberof PublicKeyRequest
     */
    'name': string;
    /**
     * Public key\'s regex username.   The `username` field define which user, in the device, may be access through this public key. 
     * @type {string}
     * @memberof PublicKeyRequest
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface PublicKeyResponse
 */
export interface PublicKeyResponse {
    /**
     * Public key\'s data.  The `data` field receives the public key enconded as `base64` string. 
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'data'?: string;
    /**
     * Public key\'s fingerprint.
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'fingerprint'?: string;
    /**
     * Public key\'s creation date.
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'created_at'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'tenant_id'?: string;
    /**
     * Public key\'s name.
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'name'?: string;
    /**
     * 
     * @type {PublicKeyFilter}
     * @memberof PublicKeyResponse
     */
    'filter'?: PublicKeyFilter;
    /**
     * Public key\'s regex username.   The `username` field define which user, in the device, may be access through this public key. 
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface RecordSession422Response
 */
export interface RecordSession422Response {
    /**
     * Error\'s message.
     * @type {string}
     * @memberof RecordSession422Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface RecordSessionRequest
 */
export interface RecordSessionRequest {
    /**
     * Session\'s UID.
     * @type {string}
     * @memberof RecordSessionRequest
     */
    'uid': string;
    /**
     * Session\'s data.
     * @type {string}
     * @memberof RecordSessionRequest
     */
    'message': string;
    /**
     * Session\'s pty width.
     * @type {number}
     * @memberof RecordSessionRequest
     */
    'width': number;
    /**
     * Session\'s pty height.
     * @type {number}
     * @memberof RecordSessionRequest
     */
    'height': number;
}
/**
 * 
 * @export
 * @interface RecordedSessionResponseInner
 */
export interface RecordedSessionResponseInner {
    /**
     * Session\'s ID
     * @type {string}
     * @memberof RecordedSessionResponseInner
     */
    'uid': string;
    /**
     * Session\'s Data
     * @type {string}
     * @memberof RecordedSessionResponseInner
     */
    'message': string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof RecordedSessionResponseInner
     */
    'tenant_id': string;
    /**
     * Session\'s time
     * @type {string}
     * @memberof RecordedSessionResponseInner
     */
    'time': string;
    /**
     * Session\'s terminal width
     * @type {number}
     * @memberof RecordedSessionResponseInner
     */
    'width': number;
    /**
     * Session\'s terminal height
     * @type {number}
     * @memberof RecordedSessionResponseInner
     */
    'height': number;
}
/**
 * 
 * @export
 * @interface RecoverPasswordRequest
 */
export interface RecoverPasswordRequest {
    /**
     * 
     * @type {RecoverPasswordRequestUsername}
     * @memberof RecoverPasswordRequest
     */
    'username': RecoverPasswordRequestUsername;
}
/**
 * @type RecoverPasswordRequestUsername
 * @export
 */
export type RecoverPasswordRequestUsername = string;

/**
 * 
 * @export
 * @interface RenameTagRequest
 */
export interface RenameTagRequest {
    /**
     * Tag\'s name.
     * @type {string}
     * @memberof RenameTagRequest
     */
    'tag'?: string;
}
/**
 * 
 * @export
 * @interface ResendEmailRequest
 */
export interface ResendEmailRequest {
    /**
     * User\'s username.
     * @type {string}
     * @memberof ResendEmailRequest
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface RuleAddTagRequest
 */
export interface RuleAddTagRequest {
    /**
     * 
     * @type {string}
     * @memberof RuleAddTagRequest
     */
    'tag': string;
}
/**
 * 
 * @export
 * @interface RuleUpdateTagsRequest
 */
export interface RuleUpdateTagsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof RuleUpdateTagsRequest
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * Session\'s UID
     * @type {string}
     * @memberof Session
     */
    'uid'?: string;
    /**
     * Device\'s UID
     * @type {string}
     * @memberof Session
     */
    'device_uid'?: string;
    /**
     * 
     * @type {Device}
     * @memberof Session
     */
    'device'?: Device;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof Session
     */
    'tenant_id'?: string;
    /**
     * Session\'s username
     * @type {string}
     * @memberof Session
     */
    'username'?: string;
    /**
     * Session\'s IP address
     * @type {string}
     * @memberof Session
     */
    'ip_address'?: string;
    /**
     * Session\'s started date
     * @type {string}
     * @memberof Session
     */
    'started_at'?: string;
    /**
     * Session\'s last seen date
     * @type {string}
     * @memberof Session
     */
    'last_seen'?: string;
    /**
     * Session\'s active status
     * @type {boolean}
     * @memberof Session
     */
    'active'?: boolean;
    /**
     * Session\'s authenticated status
     * @type {boolean}
     * @memberof Session
     */
    'authenticated'?: boolean;
    /**
     * Session\'s recorded status
     * @type {boolean}
     * @memberof Session
     */
    'recorded'?: boolean;
    /**
     * Session\'s type
     * @type {string}
     * @memberof Session
     */
    'type'?: SessionTypeEnum;
    /**
     * Session\'s terminal
     * @type {string}
     * @memberof Session
     */
    'term'?: string;
    /**
     * 
     * @type {SessionPosition}
     * @memberof Session
     */
    'position'?: SessionPosition;
}

export const SessionTypeEnum = {
    Web: 'web',
    Term: 'term'
} as const;

export type SessionTypeEnum = typeof SessionTypeEnum[keyof typeof SessionTypeEnum];

/**
 * Session\'s geolocation position
 * @export
 * @interface SessionPosition
 */
export interface SessionPosition {
    /**
     * Session\'s latitude position
     * @type {number}
     * @memberof SessionPosition
     */
    'latitude'?: number;
    /**
     * Session\'s longitude position
     * @type {number}
     * @memberof SessionPosition
     */
    'longitude'?: number;
}
/**
 * 
 * @export
 * @interface SetSSHKey200Response
 */
export interface SetSSHKey200Response {
    /**
     * Device signature
     * @type {string}
     * @memberof SetSSHKey200Response
     */
    'signature'?: string;
}
/**
 * 
 * @export
 * @interface SetSSHKeyRequest
 */
export interface SetSSHKeyRequest {
    /**
     * Device fingerprint
     * @type {string}
     * @memberof SetSSHKeyRequest
     */
    'fingerprint'?: string;
    /**
     * Device SSH public key
     * @type {string}
     * @memberof SetSSHKeyRequest
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface SetSessionAuthenticationStatusRequest
 */
export interface SetSessionAuthenticationStatusRequest {
    /**
     * Session\'s authentication status.
     * @type {boolean}
     * @memberof SetSessionAuthenticationStatusRequest
     */
    'authenticated'?: boolean;
}
/**
 * 
 * @export
 * @interface SetSessionRecordRequest
 */
export interface SetSessionRecordRequest {
    /**
     * Session\'s record status.
     * @type {boolean}
     * @memberof SetSessionRecordRequest
     */
    'session_record'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateDeviceNameRequest
 */
export interface UpdateDeviceNameRequest {
    /**
     * Device\'s new name.
     * @type {string}
     * @memberof UpdateDeviceNameRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UpdateNamespaceMemberRequest
 */
export interface UpdateNamespaceMemberRequest {
    /**
     * 
     * @type {NamespaceMemberRole}
     * @memberof UpdateNamespaceMemberRequest
     */
    'role'?: NamespaceMemberRole;
}
/**
 * 
 * @export
 * @interface UpdatePublicKeyRequest
 */
export interface UpdatePublicKeyRequest {
    /**
     * Public key\'s name.
     * @type {string}
     * @memberof UpdatePublicKeyRequest
     */
    'name': string;
    /**
     * Public key\'s username.
     * @type {string}
     * @memberof UpdatePublicKeyRequest
     */
    'username': string;
    /**
     * 
     * @type {PublicKeyFilter}
     * @memberof UpdatePublicKeyRequest
     */
    'filter': PublicKeyFilter;
}
/**
 * 
 * @export
 * @interface UpdateRecoverPasswordRequest
 */
export interface UpdateRecoverPasswordRequest {
    /**
     * User\'s password.
     * @type {string}
     * @memberof UpdateRecoverPasswordRequest
     */
    'password': string;
    /**
     * User\'s recovery token.    It is the token from the email sent to user when the user request password reset. 
     * @type {string}
     * @memberof UpdateRecoverPasswordRequest
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface UpdateTagsDeviceRequest
 */
export interface UpdateTagsDeviceRequest {
    /**
     * Device\'s Tags list
     * @type {Array<string>}
     * @memberof UpdateTagsDeviceRequest
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateTagsPublicKeyRequest
 */
export interface UpdateTagsPublicKeyRequest {
    /**
     * Public key\'s new tags.
     * @type {Set<string>}
     * @memberof UpdateTagsPublicKeyRequest
     */
    'tags'?: Set<string>;
}
/**
 * 
 * @export
 * @interface UpdateUserDataRequest
 */
export interface UpdateUserDataRequest {
    /**
     * User\'s name.
     * @type {string}
     * @memberof UpdateUserDataRequest
     */
    'name': string;
    /**
     * User\'s e-mail.
     * @type {string}
     * @memberof UpdateUserDataRequest
     */
    'email': string;
    /**
     * User\'s username.
     * @type {string}
     * @memberof UpdateUserDataRequest
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface UpdateUserPasswordRequest
 */
export interface UpdateUserPasswordRequest {
    /**
     * User current password
     * @type {string}
     * @memberof UpdateUserPasswordRequest
     */
    'current_password'?: string;
    /**
     * User new password
     * @type {string}
     * @memberof UpdateUserPasswordRequest
     */
    'new_password'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * User\'s name.
     * @type {string}
     * @memberof User
     */
    'name': string;
    /**
     * User\'s E-mail.
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * User\'s username.
     * @type {string}
     * @memberof User
     */
    'username': string;
    /**
     * User\'s password.
     * @type {string}
     * @memberof User
     */
    'password': string;
    /**
     * User\'s email marketing option.
     * @type {boolean}
     * @memberof User
     */
    'email_marketing'?: boolean;
}
/**
 * 
 * @export
 * @interface UserAuth
 */
export interface UserAuth {
    /**
     * JWT Token
     * @type {string}
     * @memberof UserAuth
     */
    'token'?: string;
    /**
     * User\'s username.
     * @type {string}
     * @memberof UserAuth
     */
    'user'?: string;
    /**
     * User\'s display name.
     * @type {string}
     * @memberof UserAuth
     */
    'name'?: string;
    /**
     * User\'s ID.
     * @type {string}
     * @memberof UserAuth
     */
    'id'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof UserAuth
     */
    'tenant'?: string;
    /**
     * 
     * @type {NamespaceMemberRole}
     * @memberof UserAuth
     */
    'role'?: NamespaceMemberRole;
    /**
     * User\'s E-mail.
     * @type {string}
     * @memberof UserAuth
     */
    'email'?: string;
}

/**
 * AnnouncementsApi - axios parameter creator
 * @export
 */
export const AnnouncementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnouncement: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getAnnouncement', 'uuid', uuid)
            const localVarPath = `/api/announcements/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAnnouncements: async (page?: number, perPage?: number, orderBy?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnnouncementsApi - functional programming interface
 * @export
 */
export const AnnouncementsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnnouncementsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnouncement(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnouncement(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAnnouncements(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnnouncementShort>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAnnouncements(page, perPage, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AnnouncementsApi - factory interface
 * @export
 */
export const AnnouncementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnnouncementsApiFp(configuration)
    return {
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnouncement(uuid: string, options?: any): AxiosPromise<Announcement> {
            return localVarFp.getAnnouncement(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAnnouncements(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', options?: any): AxiosPromise<Array<AnnouncementShort>> {
            return localVarFp.listAnnouncements(page, perPage, orderBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnnouncementsApi - object-oriented interface
 * @export
 * @class AnnouncementsApi
 * @extends {BaseAPI}
 */
export class AnnouncementsApi extends BaseAPI {
    /**
     * Get a announcement.
     * @summary Get a announcement
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnouncementsApi
     */
    public getAnnouncement(uuid: string, options?: AxiosRequestConfig) {
        return AnnouncementsApiFp(this.configuration).getAnnouncement(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the announcements posted by ShellHub Cloud.
     * @summary List announcements
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {'asc' | 'desc'} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnouncementsApi
     */
    public listAnnouncements(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return AnnouncementsApiFp(this.configuration).listAnnouncements(page, perPage, orderBy, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BillingApi - axios parameter creator
 * @export
 */
export const BillingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a new payment method.
         * @summary Add payment method
         * @param {string} id Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPaymentMethod: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addPaymentMethod', 'id', id)
            const localVarPath = `/api/billing/{id}/payment-method`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel the subscription.
         * @summary Cancel subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscription: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Choice devices when device\'s limit is rechead.
         * @summary Choice devices
         * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choiceDevices: async (choiceDevicesRequest?: ChoiceDevicesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/device-choice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(choiceDevicesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create the subscription.
         * @summary Create subscription
         * @param {CreateSubscriptionRequest} [createSubscriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription: async (createSubscriptionRequest?: CreateSubscriptionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSubscriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deattach a payment method.
         * @summary Deattach payment method
         * @param {string} id Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deattachPaymentMethod: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deattachPaymentMethod', 'id', id)
            const localVarPath = `/api/billing/{id}/payment-method`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most used devices.
         * @summary Get devices most used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesMostUsed: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/devices-most-used`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the subscription.
         * @summary Get subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the payment method.
         * @summary Update payment method
         * @param {string} id Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentMethod: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePaymentMethod', 'id', id)
            const localVarPath = `/api/billing/{id}/payment-method`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingApi - functional programming interface
 * @export
 */
export const BillingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a new payment method.
         * @summary Add payment method
         * @param {string} id Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPaymentMethod(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddPaymentMethod200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPaymentMethod(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel the subscription.
         * @summary Cancel subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelSubscription(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelSubscription(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Choice devices when device\'s limit is rechead.
         * @summary Choice devices
         * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async choiceDevices(choiceDevicesRequest?: ChoiceDevicesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.choiceDevices(choiceDevicesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create the subscription.
         * @summary Create subscription
         * @param {CreateSubscriptionRequest} [createSubscriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscription(createSubscriptionRequest?: CreateSubscriptionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSubscription200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscription(createSubscriptionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deattach a payment method.
         * @summary Deattach payment method
         * @param {string} id Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deattachPaymentMethod(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddPaymentMethod200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deattachPaymentMethod(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the most used devices.
         * @summary Get devices most used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevicesMostUsed(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevicesMostUsed(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the subscription.
         * @summary Get subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscription(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSubscription200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscription(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the payment method.
         * @summary Update payment method
         * @param {string} id Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePaymentMethod(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddPaymentMethod200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePaymentMethod(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BillingApi - factory interface
 * @export
 */
export const BillingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingApiFp(configuration)
    return {
        /**
         * Add a new payment method.
         * @summary Add payment method
         * @param {string} id Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPaymentMethod(id: string, options?: any): AxiosPromise<AddPaymentMethod200Response> {
            return localVarFp.addPaymentMethod(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel the subscription.
         * @summary Cancel subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscription(options?: any): AxiosPromise<void> {
            return localVarFp.cancelSubscription(options).then((request) => request(axios, basePath));
        },
        /**
         * Choice devices when device\'s limit is rechead.
         * @summary Choice devices
         * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choiceDevices(choiceDevicesRequest?: ChoiceDevicesRequest, options?: any): AxiosPromise<void> {
            return localVarFp.choiceDevices(choiceDevicesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create the subscription.
         * @summary Create subscription
         * @param {CreateSubscriptionRequest} [createSubscriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(createSubscriptionRequest?: CreateSubscriptionRequest, options?: any): AxiosPromise<CreateSubscription200Response> {
            return localVarFp.createSubscription(createSubscriptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deattach a payment method.
         * @summary Deattach payment method
         * @param {string} id Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deattachPaymentMethod(id: string, options?: any): AxiosPromise<AddPaymentMethod200Response> {
            return localVarFp.deattachPaymentMethod(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most used devices.
         * @summary Get devices most used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesMostUsed(options?: any): AxiosPromise<Array<Device>> {
            return localVarFp.getDevicesMostUsed(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the subscription.
         * @summary Get subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription(options?: any): AxiosPromise<GetSubscription200Response> {
            return localVarFp.getSubscription(options).then((request) => request(axios, basePath));
        },
        /**
         * Update the payment method.
         * @summary Update payment method
         * @param {string} id Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentMethod(id: string, options?: any): AxiosPromise<AddPaymentMethod200Response> {
            return localVarFp.updatePaymentMethod(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingApi - object-oriented interface
 * @export
 * @class BillingApi
 * @extends {BaseAPI}
 */
export class BillingApi extends BaseAPI {
    /**
     * Add a new payment method.
     * @summary Add payment method
     * @param {string} id Payment method ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public addPaymentMethod(id: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).addPaymentMethod(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel the subscription.
     * @summary Cancel subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public cancelSubscription(options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).cancelSubscription(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Choice devices when device\'s limit is rechead.
     * @summary Choice devices
     * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public choiceDevices(choiceDevicesRequest?: ChoiceDevicesRequest, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).choiceDevices(choiceDevicesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create the subscription.
     * @summary Create subscription
     * @param {CreateSubscriptionRequest} [createSubscriptionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public createSubscription(createSubscriptionRequest?: CreateSubscriptionRequest, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).createSubscription(createSubscriptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deattach a payment method.
     * @summary Deattach payment method
     * @param {string} id Payment method ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public deattachPaymentMethod(id: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).deattachPaymentMethod(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most used devices.
     * @summary Get devices most used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getDevicesMostUsed(options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getDevicesMostUsed(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the subscription.
     * @summary Get subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getSubscription(options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getSubscription(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the payment method.
     * @summary Update payment method
     * @param {string} id Payment method ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public updatePaymentMethod(id: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).updatePaymentMethod(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CloudApi - axios parameter creator
 * @export
 */
export const CloudApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a new payment method.
         * @summary Add payment method
         * @param {string} id Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPaymentMethod: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addPaymentMethod', 'id', id)
            const localVarPath = `/api/billing/{id}/payment-method`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel the subscription.
         * @summary Cancel subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscription: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Choice devices when device\'s limit is rechead.
         * @summary Choice devices
         * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choiceDevices: async (choiceDevicesRequest?: ChoiceDevicesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/device-choice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(choiceDevicesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Close a session.
         * @summary Close session
         * @param {string} uid 
         * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clsoeSession: async (uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('clsoeSession', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}/close`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clsoeSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a firewall rule.
         * @summary Create firewall rule
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRule: async (firewallRulesRequest?: FirewallRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create the subscription.
         * @summary Create subscription
         * @param {CreateSubscriptionRequest} [createSubscriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription: async (createSubscriptionRequest?: CreateSubscriptionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSubscriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deattach a payment method.
         * @summary Deattach payment method
         * @param {string} id Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deattachPaymentMethod: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deattachPaymentMethod', 'id', id)
            const localVarPath = `/api/billing/{id}/payment-method`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRule: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFirewallRule', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most used devices.
         * @summary Get devices most used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesMostUsed: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/devices-most-used`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRule: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFirewallRule', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRules: async (page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get session recorded data.
         * @summary Get session recorded data
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionData: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getSessionData', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}/play`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the subscription.
         * @summary Get subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate the activation link for user.
         * @summary Validate activation link
         * @param {string} email User\&#39;s email.
         * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidateAccount: async (email: string, token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('getValidateAccount', 'email', email)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getValidateAccount', 'token', token)
            const localVarPath = `/api/user/validation_account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Record data about session session.
         * @summary Record session
         * @param {string} uid 
         * @param {RecordSessionRequest} [recordSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordSession: async (uid: string, recordSessionRequest?: RecordSessionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('recordSession', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}/record`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recordSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a recovery email to the user.
         * @summary Recover password
         * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverPassword: async (recoverPasswordRequest?: RecoverPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/recover_password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recoverPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register user
         * @summary Register user
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser: async (user?: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resend confirmation to user.
         * @summary Resend confirmation
         * @param {ResendEmailRequest} [resendEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEmail: async (resendEmailRequest?: ResendEmailRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/resend_email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resendEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a tag to firewall rule
         * @summary Add a tag to firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleAddTag: async (id: string, ruleAddTagRequest?: RuleAddTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ruleAddTag', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleAddTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a tag from firewall rule
         * @summary Remove a tag from firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleDeleteTag: async (id: string, ruleAddTagRequest?: RuleAddTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ruleDeleteTag', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleAddTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update tags in firewall rule
         * @summary Update tags in firewall rule
         * @param {string} id 
         * @param {RuleUpdateTagsRequest} [ruleUpdateTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleUpdateTags: async (id: string, ruleUpdateTagsRequest?: RuleUpdateTagsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ruleUpdateTags', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleUpdateTagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule
         * @param {number} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRule: async (id: number, firewallRulesRequest?: FirewallRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFirewallRule', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the payment method.
         * @summary Update payment method
         * @param {string} id Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentMethod: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePaymentMethod', 'id', id)
            const localVarPath = `/api/billing/{id}/payment-method`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user password from a recovery token got from email.
         * @summary Update user password
         * @param {string} uid User\&#39;s UID.
         * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecoverPassword: async (uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateRecoverPassword', 'uid', uid)
            const localVarPath = `/api/user/{uid}/update_password`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRecoverPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudApi - functional programming interface
 * @export
 */
export const CloudApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloudApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a new payment method.
         * @summary Add payment method
         * @param {string} id Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPaymentMethod(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddPaymentMethod200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPaymentMethod(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel the subscription.
         * @summary Cancel subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelSubscription(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelSubscription(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Choice devices when device\'s limit is rechead.
         * @summary Choice devices
         * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async choiceDevices(choiceDevicesRequest?: ChoiceDevicesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.choiceDevices(choiceDevicesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Close a session.
         * @summary Close session
         * @param {string} uid 
         * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clsoeSession(uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clsoeSession(uid, clsoeSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a firewall rule.
         * @summary Create firewall rule
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFirewallRule(firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFirewallRule(firewallRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create the subscription.
         * @summary Create subscription
         * @param {CreateSubscriptionRequest} [createSubscriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscription(createSubscriptionRequest?: CreateSubscriptionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSubscription200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscription(createSubscriptionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deattach a payment method.
         * @summary Deattach payment method
         * @param {string} id Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deattachPaymentMethod(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddPaymentMethod200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deattachPaymentMethod(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFirewallRule(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFirewallRule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the most used devices.
         * @summary Get devices most used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevicesMostUsed(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevicesMostUsed(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRule(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRules(page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FirewallRulesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRules(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get session recorded data.
         * @summary Get session recorded data
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionData(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RecordedSessionResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionData(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the subscription.
         * @summary Get subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscription(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSubscription200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscription(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validate the activation link for user.
         * @summary Validate activation link
         * @param {string} email User\&#39;s email.
         * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValidateAccount(email: string, token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getValidateAccount(email, token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Record data about session session.
         * @summary Record session
         * @param {string} uid 
         * @param {RecordSessionRequest} [recordSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordSession(uid: string, recordSessionRequest?: RecordSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordSession(uid, recordSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send a recovery email to the user.
         * @summary Recover password
         * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoverPassword(recoverPasswordRequest?: RecoverPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoverPassword(recoverPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register user
         * @summary Register user
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUser(user?: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resend confirmation to user.
         * @summary Resend confirmation
         * @param {ResendEmailRequest} [resendEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendEmail(resendEmailRequest?: ResendEmailRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendEmail(resendEmailRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a tag to firewall rule
         * @summary Add a tag to firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ruleAddTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ruleAddTag(id, ruleAddTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a tag from firewall rule
         * @summary Remove a tag from firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ruleDeleteTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ruleDeleteTag(id, ruleAddTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update tags in firewall rule
         * @summary Update tags in firewall rule
         * @param {string} id 
         * @param {RuleUpdateTagsRequest} [ruleUpdateTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ruleUpdateTags(id: string, ruleUpdateTagsRequest?: RuleUpdateTagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ruleUpdateTags(id, ruleUpdateTagsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule
         * @param {number} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFirewallRule(id: number, firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFirewallRule(id, firewallRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the payment method.
         * @summary Update payment method
         * @param {string} id Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePaymentMethod(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddPaymentMethod200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePaymentMethod(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update user password from a recovery token got from email.
         * @summary Update user password
         * @param {string} uid User\&#39;s UID.
         * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecoverPassword(uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecoverPassword(uid, updateRecoverPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CloudApi - factory interface
 * @export
 */
export const CloudApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloudApiFp(configuration)
    return {
        /**
         * Add a new payment method.
         * @summary Add payment method
         * @param {string} id Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPaymentMethod(id: string, options?: any): AxiosPromise<AddPaymentMethod200Response> {
            return localVarFp.addPaymentMethod(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel the subscription.
         * @summary Cancel subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscription(options?: any): AxiosPromise<void> {
            return localVarFp.cancelSubscription(options).then((request) => request(axios, basePath));
        },
        /**
         * Choice devices when device\'s limit is rechead.
         * @summary Choice devices
         * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choiceDevices(choiceDevicesRequest?: ChoiceDevicesRequest, options?: any): AxiosPromise<void> {
            return localVarFp.choiceDevices(choiceDevicesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Close a session.
         * @summary Close session
         * @param {string} uid 
         * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clsoeSession(uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options?: any): AxiosPromise<void> {
            return localVarFp.clsoeSession(uid, clsoeSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a firewall rule.
         * @summary Create firewall rule
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRule(firewallRulesRequest?: FirewallRulesRequest, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.createFirewallRule(firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create the subscription.
         * @summary Create subscription
         * @param {CreateSubscriptionRequest} [createSubscriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(createSubscriptionRequest?: CreateSubscriptionRequest, options?: any): AxiosPromise<CreateSubscription200Response> {
            return localVarFp.createSubscription(createSubscriptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deattach a payment method.
         * @summary Deattach payment method
         * @param {string} id Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deattachPaymentMethod(id: string, options?: any): AxiosPromise<AddPaymentMethod200Response> {
            return localVarFp.deattachPaymentMethod(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRule(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFirewallRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most used devices.
         * @summary Get devices most used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesMostUsed(options?: any): AxiosPromise<Array<Device>> {
            return localVarFp.getDevicesMostUsed(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRule(id: number, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.getFirewallRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRules(page?: number, perPage?: number, options?: any): AxiosPromise<Array<FirewallRulesResponse>> {
            return localVarFp.getFirewallRules(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get session recorded data.
         * @summary Get session recorded data
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionData(uid: string, options?: any): AxiosPromise<Array<RecordedSessionResponseInner>> {
            return localVarFp.getSessionData(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the subscription.
         * @summary Get subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription(options?: any): AxiosPromise<GetSubscription200Response> {
            return localVarFp.getSubscription(options).then((request) => request(axios, basePath));
        },
        /**
         * Validate the activation link for user.
         * @summary Validate activation link
         * @param {string} email User\&#39;s email.
         * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidateAccount(email: string, token: string, options?: any): AxiosPromise<void> {
            return localVarFp.getValidateAccount(email, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Record data about session session.
         * @summary Record session
         * @param {string} uid 
         * @param {RecordSessionRequest} [recordSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordSession(uid: string, recordSessionRequest?: RecordSessionRequest, options?: any): AxiosPromise<void> {
            return localVarFp.recordSession(uid, recordSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a recovery email to the user.
         * @summary Recover password
         * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverPassword(recoverPasswordRequest?: RecoverPasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.recoverPassword(recoverPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Register user
         * @summary Register user
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(user?: User, options?: any): AxiosPromise<void> {
            return localVarFp.registerUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         * Resend confirmation to user.
         * @summary Resend confirmation
         * @param {ResendEmailRequest} [resendEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEmail(resendEmailRequest?: ResendEmailRequest, options?: any): AxiosPromise<void> {
            return localVarFp.resendEmail(resendEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a tag to firewall rule
         * @summary Add a tag to firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleAddTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: any): AxiosPromise<void> {
            return localVarFp.ruleAddTag(id, ruleAddTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a tag from firewall rule
         * @summary Remove a tag from firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleDeleteTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: any): AxiosPromise<void> {
            return localVarFp.ruleDeleteTag(id, ruleAddTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update tags in firewall rule
         * @summary Update tags in firewall rule
         * @param {string} id 
         * @param {RuleUpdateTagsRequest} [ruleUpdateTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleUpdateTags(id: string, ruleUpdateTagsRequest?: RuleUpdateTagsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.ruleUpdateTags(id, ruleUpdateTagsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule
         * @param {number} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRule(id: number, firewallRulesRequest?: FirewallRulesRequest, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.updateFirewallRule(id, firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the payment method.
         * @summary Update payment method
         * @param {string} id Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentMethod(id: string, options?: any): AxiosPromise<AddPaymentMethod200Response> {
            return localVarFp.updatePaymentMethod(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user password from a recovery token got from email.
         * @summary Update user password
         * @param {string} uid User\&#39;s UID.
         * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecoverPassword(uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateRecoverPassword(uid, updateRecoverPasswordRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CloudApi - object-oriented interface
 * @export
 * @class CloudApi
 * @extends {BaseAPI}
 */
export class CloudApi extends BaseAPI {
    /**
     * Add a new payment method.
     * @summary Add payment method
     * @param {string} id Payment method ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public addPaymentMethod(id: string, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).addPaymentMethod(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel the subscription.
     * @summary Cancel subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public cancelSubscription(options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).cancelSubscription(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Choice devices when device\'s limit is rechead.
     * @summary Choice devices
     * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public choiceDevices(choiceDevicesRequest?: ChoiceDevicesRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).choiceDevices(choiceDevicesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Close a session.
     * @summary Close session
     * @param {string} uid 
     * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public clsoeSession(uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).clsoeSession(uid, clsoeSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a firewall rule.
     * @summary Create firewall rule
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public createFirewallRule(firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).createFirewallRule(firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create the subscription.
     * @summary Create subscription
     * @param {CreateSubscriptionRequest} [createSubscriptionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public createSubscription(createSubscriptionRequest?: CreateSubscriptionRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).createSubscription(createSubscriptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deattach a payment method.
     * @summary Deattach payment method
     * @param {string} id Payment method ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public deattachPaymentMethod(id: string, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).deattachPaymentMethod(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a firewall rule.
     * @summary Delete firewall rule
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public deleteFirewallRule(id: number, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).deleteFirewallRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most used devices.
     * @summary Get devices most used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public getDevicesMostUsed(options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).getDevicesMostUsed(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a firewall rule.
     * @summary Get firewall rule
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public getFirewallRule(id: number, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).getFirewallRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of firewall rules.
     * @summary Get firewall rules
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public getFirewallRules(page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).getFirewallRules(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get session recorded data.
     * @summary Get session recorded data
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public getSessionData(uid: string, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).getSessionData(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the subscription.
     * @summary Get subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public getSubscription(options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).getSubscription(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate the activation link for user.
     * @summary Validate activation link
     * @param {string} email User\&#39;s email.
     * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public getValidateAccount(email: string, token: string, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).getValidateAccount(email, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Record data about session session.
     * @summary Record session
     * @param {string} uid 
     * @param {RecordSessionRequest} [recordSessionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public recordSession(uid: string, recordSessionRequest?: RecordSessionRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).recordSession(uid, recordSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a recovery email to the user.
     * @summary Recover password
     * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public recoverPassword(recoverPasswordRequest?: RecoverPasswordRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).recoverPassword(recoverPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register user
     * @summary Register user
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public registerUser(user?: User, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).registerUser(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resend confirmation to user.
     * @summary Resend confirmation
     * @param {ResendEmailRequest} [resendEmailRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public resendEmail(resendEmailRequest?: ResendEmailRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).resendEmail(resendEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a tag to firewall rule
     * @summary Add a tag to firewall rule
     * @param {string} id 
     * @param {RuleAddTagRequest} [ruleAddTagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public ruleAddTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).ruleAddTag(id, ruleAddTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a tag from firewall rule
     * @summary Remove a tag from firewall rule
     * @param {string} id 
     * @param {RuleAddTagRequest} [ruleAddTagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public ruleDeleteTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).ruleDeleteTag(id, ruleAddTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update tags in firewall rule
     * @summary Update tags in firewall rule
     * @param {string} id 
     * @param {RuleUpdateTagsRequest} [ruleUpdateTagsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public ruleUpdateTags(id: string, ruleUpdateTagsRequest?: RuleUpdateTagsRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).ruleUpdateTags(id, ruleUpdateTagsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a firewall rule.
     * @summary Update firewall rule
     * @param {number} id 
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public updateFirewallRule(id: number, firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).updateFirewallRule(id, firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the payment method.
     * @summary Update payment method
     * @param {string} id Payment method ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public updatePaymentMethod(id: string, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).updatePaymentMethod(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user password from a recovery token got from email.
     * @summary Update user password
     * @param {string} uid User\&#39;s UID.
     * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public updateRecoverPassword(uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).updateRecoverPassword(uid, updateRecoverPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get info about ShellHub instance.
         * @summary Get info
         * @param {string} [agentVersion] Agent\&#39;s version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo: async (agentVersion?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (agentVersion !== undefined) {
                localVarQueryParameter['agent_version'] = agentVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Get info about ShellHub instance.
         * @summary Get info
         * @param {string} [agentVersion] Agent\&#39;s version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInfo(agentVersion?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Info>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInfo(agentVersion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Get info about ShellHub instance.
         * @summary Get info
         * @param {string} [agentVersion] Agent\&#39;s version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(agentVersion?: string, options?: any): AxiosPromise<Info> {
            return localVarFp.getInfo(agentVersion, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Get info about ShellHub instance.
     * @summary Get info
     * @param {string} [agentVersion] Agent\&#39;s version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getInfo(agentVersion?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getInfo(agentVersion, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DevicesApi - axios parameter creator
 * @export
 */
export const DevicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Change device status to `accepted`.
         * @summary Accept device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDevice: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('acceptDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}/accept`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceTag: async (uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('createDeviceTag', 'uid', uid)
            const localVarPath = `/api/devices/{uid}/tags`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDeviceTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a device.
         * @summary Delete device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a tag from device.
         * @summary Delete a tag from device
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceTag: async (uid: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteDeviceTag', 'uid', uid)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('deleteDeviceTag', 'tag', tag)
            const localVarPath = `/api/devices/{uid}/tags/{tag}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a device.
         * @summary Get device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevice: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of devices.
         * @summary Get devices
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices: async (filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get stats ShellHub instance.
         * @summary Get stats ShellHub instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusDevices: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Auth a device.  Every 30 seconds, this route is hit by internal ShellHub to check device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {PostAuthDeviceRequest} [postAuthDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthDevice: async (xRealIP?: string, postAuthDeviceRequest?: PostAuthDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/devices/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xRealIP !== undefined && xRealIP !== null) {
                localVarHeaderParameter['X-Real-IP'] = String(xRealIP);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postAuthDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Auth a device.  Every 30 seconds, this route is hit by internal ShellHub to check device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {PostAuthDeviceRequest} [postAuthDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthDevice_1: async (xRealIP?: string, postAuthDeviceRequest?: PostAuthDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/device`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xRealIP !== undefined && xRealIP !== null) {
                localVarHeaderParameter['X-Real-IP'] = String(xRealIP);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postAuthDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s name.
         * @summary Update device name
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameRequest} [updateDeviceNameRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceName: async (uid: string, updateDeviceNameRequest?: UpdateDeviceNameRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceName', 'uid', uid)
            const localVarPath = `/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDeviceNameRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s status.
         * @summary Update device status
         * @param {string} uid Device\&#39;s UID
         * @param {'accept' | 'reject' | 'pending' | 'unused'} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatus: async (uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceStatus', 'uid', uid)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateDeviceStatus', 'status', status)
            const localVarPath = `/api/devices/{uid}/{status}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update tags to device
         * @summary Update tags to device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsDevice: async (uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateTagsDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}/tags`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagsDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DevicesApi - functional programming interface
 * @export
 */
export const DevicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DevicesApiAxiosParamCreator(configuration)
    return {
        /**
         * Change device status to `accepted`.
         * @summary Accept device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptDevice(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptDevice(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeviceTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeviceTag(uid, createDeviceTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a device.
         * @summary Delete device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDevice(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDevice(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a tag from device.
         * @summary Delete a tag from device
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeviceTag(uid: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeviceTag(uid, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a device.
         * @summary Get device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevice(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevice(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of devices.
         * @summary Get devices
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevices(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevices(filter, page, perPage, status, sortBy, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get stats ShellHub instance.
         * @summary Get stats ShellHub instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusDevices(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatusDevices200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusDevices(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Auth a device.  Every 30 seconds, this route is hit by internal ShellHub to check device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {PostAuthDeviceRequest} [postAuthDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAuthDevice(xRealIP?: string, postAuthDeviceRequest?: PostAuthDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostAuthDevice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAuthDevice(xRealIP, postAuthDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Auth a device.  Every 30 seconds, this route is hit by internal ShellHub to check device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {PostAuthDeviceRequest} [postAuthDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAuthDevice_1(xRealIP?: string, postAuthDeviceRequest?: PostAuthDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostAuthDevice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAuthDevice_1(xRealIP, postAuthDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update device\'s name.
         * @summary Update device name
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameRequest} [updateDeviceNameRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceName(uid: string, updateDeviceNameRequest?: UpdateDeviceNameRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceName(uid, updateDeviceNameRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update device\'s status.
         * @summary Update device status
         * @param {string} uid Device\&#39;s UID
         * @param {'accept' | 'reject' | 'pending' | 'unused'} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceStatus(uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceStatus(uid, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update tags to device
         * @summary Update tags to device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTagsDevice(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTagsDevice(uid, updateTagsDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DevicesApi - factory interface
 * @export
 */
export const DevicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DevicesApiFp(configuration)
    return {
        /**
         * Change device status to `accepted`.
         * @summary Accept device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDevice(uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.acceptDevice(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createDeviceTag(uid, createDeviceTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a device.
         * @summary Delete device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice(uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDevice(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a tag from device.
         * @summary Delete a tag from device
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceTag(uid: string, tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDeviceTag(uid, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a device.
         * @summary Get device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevice(uid: string, options?: any): AxiosPromise<Device> {
            return localVarFp.getDevice(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of devices.
         * @summary Get devices
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: any): AxiosPromise<Array<Device>> {
            return localVarFp.getDevices(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Get stats ShellHub instance.
         * @summary Get stats ShellHub instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusDevices(options?: any): AxiosPromise<GetStatusDevices200Response> {
            return localVarFp.getStatusDevices(options).then((request) => request(axios, basePath));
        },
        /**
         * Auth a device.  Every 30 seconds, this route is hit by internal ShellHub to check device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {PostAuthDeviceRequest} [postAuthDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthDevice(xRealIP?: string, postAuthDeviceRequest?: PostAuthDeviceRequest, options?: any): AxiosPromise<PostAuthDevice200Response> {
            return localVarFp.postAuthDevice(xRealIP, postAuthDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Auth a device.  Every 30 seconds, this route is hit by internal ShellHub to check device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {PostAuthDeviceRequest} [postAuthDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthDevice_1(xRealIP?: string, postAuthDeviceRequest?: PostAuthDeviceRequest, options?: any): AxiosPromise<PostAuthDevice200Response> {
            return localVarFp.postAuthDevice_1(xRealIP, postAuthDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s name.
         * @summary Update device name
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameRequest} [updateDeviceNameRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceName(uid: string, updateDeviceNameRequest?: UpdateDeviceNameRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateDeviceName(uid, updateDeviceNameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s status.
         * @summary Update device status
         * @param {string} uid Device\&#39;s UID
         * @param {'accept' | 'reject' | 'pending' | 'unused'} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatus(uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options?: any): AxiosPromise<void> {
            return localVarFp.updateDeviceStatus(uid, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Update tags to device
         * @summary Update tags to device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsDevice(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateTagsDevice(uid, updateTagsDeviceRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DevicesApi - object-oriented interface
 * @export
 * @class DevicesApi
 * @extends {BaseAPI}
 */
export class DevicesApi extends BaseAPI {
    /**
     * Change device status to `accepted`.
     * @summary Accept device
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public acceptDevice(uid: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).acceptDevice(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a tag
     * @summary Create a tag
     * @param {string} uid Device\&#39;s UID
     * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public createDeviceTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).createDeviceTag(uid, createDeviceTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a device.
     * @summary Delete device
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public deleteDevice(uid: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).deleteDevice(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a tag from device.
     * @summary Delete a tag from device
     * @param {string} uid Device\&#39;s UID
     * @param {string} tag Device\&#39;s tag name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public deleteDeviceTag(uid: string, tag: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).deleteDeviceTag(uid, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a device.
     * @summary Get device
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDevice(uid: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDevice(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of devices.
     * @summary Get devices
     * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {DeviceStatus} [status] Device\&#39;s status
     * @param {string} [sortBy] Device\&#39;s property to sort of
     * @param {'asc' | 'desc'} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDevices(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDevices(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get stats ShellHub instance.
     * @summary Get stats ShellHub instance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getStatusDevices(options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getStatusDevices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Auth a device.  Every 30 seconds, this route is hit by internal ShellHub to check device availability. 
     * @summary Auth device
     * @param {string} [xRealIP] 
     * @param {PostAuthDeviceRequest} [postAuthDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public postAuthDevice(xRealIP?: string, postAuthDeviceRequest?: PostAuthDeviceRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).postAuthDevice(xRealIP, postAuthDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Auth a device.  Every 30 seconds, this route is hit by internal ShellHub to check device availability. 
     * @summary Auth device
     * @param {string} [xRealIP] 
     * @param {PostAuthDeviceRequest} [postAuthDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public postAuthDevice_1(xRealIP?: string, postAuthDeviceRequest?: PostAuthDeviceRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).postAuthDevice_1(xRealIP, postAuthDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s name.
     * @summary Update device name
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateDeviceNameRequest} [updateDeviceNameRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public updateDeviceName(uid: string, updateDeviceNameRequest?: UpdateDeviceNameRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).updateDeviceName(uid, updateDeviceNameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s status.
     * @summary Update device status
     * @param {string} uid Device\&#39;s UID
     * @param {'accept' | 'reject' | 'pending' | 'unused'} status Device\&#39;s status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public updateDeviceStatus(uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).updateDeviceStatus(uid, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update tags to device
     * @summary Update tags to device
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public updateTagsDevice(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).updateTagsDevice(uid, updateTagsDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NamespacesApi - axios parameter creator
 * @export
 */
export const NamespacesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a member to a namespace.
         * @summary Add a member to a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNamespaceMember: async (tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('addNamespaceMember', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addNamespaceMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a namespace.
         * @summary Create namespace
         * @param {CreateNamespaceRequest} [createNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespace: async (createNamespaceRequest?: CreateNamespaceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNamespaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespace: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('deleteNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceRequest} [createNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespace: async (tenant: string, createNamespaceRequest?: CreateNamespaceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('editNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNamespaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a namespace.
         * @summary Get a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespace: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
         * @summary Get a new namespace\'s token
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceToken: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getNamespaceToken', 'tenant', tenant)
            const localVarPath = `/api/auth/token/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces list
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaces: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a member from a namespace.
         * @summary Remove a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNamespaceMember: async (tenant: string, uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('removeNamespaceMember', 'tenant', tenant)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('removeNamespaceMember', 'uid', uid)
            const localVarPath = `/api/namespaces/{tenant}/members/{uid}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a member role from a namespace.
         * @summary Update a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNamespaceMember: async (tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('updateNamespaceMember', 'tenant', tenant)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateNamespaceMember', 'uid', uid)
            const localVarPath = `/api/namespaces/{tenant}/members/{uid}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNamespaceMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NamespacesApi - functional programming interface
 * @export
 */
export const NamespacesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NamespacesApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a member to a namespace.
         * @summary Add a member to a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNamespaceMember(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNamespaceMember(tenant, addNamespaceMemberRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a namespace.
         * @summary Create namespace
         * @param {CreateNamespaceRequest} [createNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNamespace(createNamespaceRequest?: CreateNamespaceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNamespace(createNamespaceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNamespace(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNamespace(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceRequest} [createNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editNamespace(tenant: string, createNamespaceRequest?: CreateNamespaceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editNamespace(tenant, createNamespaceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a namespace.
         * @summary Get a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespace(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespace(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
         * @summary Get a new namespace\'s token
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespaceToken(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaceToken(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces list
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespaces(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Namespace>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaces(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a member from a namespace.
         * @summary Remove a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeNamespaceMember(tenant: string, uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeNamespaceMember(tenant, uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a member role from a namespace.
         * @summary Update a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNamespaceMember(tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNamespaceMember(tenant, uid, updateNamespaceMemberRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NamespacesApi - factory interface
 * @export
 */
export const NamespacesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NamespacesApiFp(configuration)
    return {
        /**
         * Add a member to a namespace.
         * @summary Add a member to a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNamespaceMember(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: any): AxiosPromise<Namespace> {
            return localVarFp.addNamespaceMember(tenant, addNamespaceMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a namespace.
         * @summary Create namespace
         * @param {CreateNamespaceRequest} [createNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespace(createNamespaceRequest?: CreateNamespaceRequest, options?: any): AxiosPromise<Namespace> {
            return localVarFp.createNamespace(createNamespaceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespace(tenant: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteNamespace(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceRequest} [createNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespace(tenant: string, createNamespaceRequest?: CreateNamespaceRequest, options?: any): AxiosPromise<Namespace> {
            return localVarFp.editNamespace(tenant, createNamespaceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a namespace.
         * @summary Get a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespace(tenant: string, options?: any): AxiosPromise<Namespace> {
            return localVarFp.getNamespace(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
         * @summary Get a new namespace\'s token
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceToken(tenant: string, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.getNamespaceToken(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces list
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaces(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<Array<Namespace>> {
            return localVarFp.getNamespaces(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a member from a namespace.
         * @summary Remove a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNamespaceMember(tenant: string, uid: string, options?: any): AxiosPromise<Namespace> {
            return localVarFp.removeNamespaceMember(tenant, uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a member role from a namespace.
         * @summary Update a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNamespaceMember(tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateNamespaceMember(tenant, uid, updateNamespaceMemberRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NamespacesApi - object-oriented interface
 * @export
 * @class NamespacesApi
 * @extends {BaseAPI}
 */
export class NamespacesApi extends BaseAPI {
    /**
     * Add a member to a namespace.
     * @summary Add a member to a namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public addNamespaceMember(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).addNamespaceMember(tenant, addNamespaceMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a namespace.
     * @summary Create namespace
     * @param {CreateNamespaceRequest} [createNamespaceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public createNamespace(createNamespaceRequest?: CreateNamespaceRequest, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).createNamespace(createNamespaceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a namespace.
     * @summary Delete namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public deleteNamespace(tenant: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).deleteNamespace(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit a namespace.
     * @summary Edit namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {CreateNamespaceRequest} [createNamespaceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public editNamespace(tenant: string, createNamespaceRequest?: CreateNamespaceRequest, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).editNamespace(tenant, createNamespaceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a namespace.
     * @summary Get a namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getNamespace(tenant: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).getNamespace(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
     * @summary Get a new namespace\'s token
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getNamespaceToken(tenant: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).getNamespaceToken(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of namespaces.
     * @summary Get namespaces list
     * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getNamespaces(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).getNamespaces(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a member from a namespace.
     * @summary Remove a member from a namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} uid Member\&#39;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public removeNamespaceMember(tenant: string, uid: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).removeNamespaceMember(tenant, uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a member role from a namespace.
     * @summary Update a member from a namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} uid Member\&#39;s ID
     * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public updateNamespaceMember(tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).updateNamespaceMember(tenant, uid, updateNamespaceMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RulesApi - axios parameter creator
 * @export
 */
export const RulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a firewall rule.
         * @summary Create firewall rule
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRule: async (firewallRulesRequest?: FirewallRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRule: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFirewallRule', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRule: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFirewallRule', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRules: async (page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a tag to firewall rule
         * @summary Add a tag to firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleAddTag: async (id: string, ruleAddTagRequest?: RuleAddTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ruleAddTag', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleAddTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a tag from firewall rule
         * @summary Remove a tag from firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleDeleteTag: async (id: string, ruleAddTagRequest?: RuleAddTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ruleDeleteTag', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleAddTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update tags in firewall rule
         * @summary Update tags in firewall rule
         * @param {string} id 
         * @param {RuleUpdateTagsRequest} [ruleUpdateTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleUpdateTags: async (id: string, ruleUpdateTagsRequest?: RuleUpdateTagsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ruleUpdateTags', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleUpdateTagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule
         * @param {number} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRule: async (id: number, firewallRulesRequest?: FirewallRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFirewallRule', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RulesApi - functional programming interface
 * @export
 */
export const RulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RulesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a firewall rule.
         * @summary Create firewall rule
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFirewallRule(firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFirewallRule(firewallRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFirewallRule(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFirewallRule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRule(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRules(page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FirewallRulesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRules(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a tag to firewall rule
         * @summary Add a tag to firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ruleAddTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ruleAddTag(id, ruleAddTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a tag from firewall rule
         * @summary Remove a tag from firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ruleDeleteTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ruleDeleteTag(id, ruleAddTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update tags in firewall rule
         * @summary Update tags in firewall rule
         * @param {string} id 
         * @param {RuleUpdateTagsRequest} [ruleUpdateTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ruleUpdateTags(id: string, ruleUpdateTagsRequest?: RuleUpdateTagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ruleUpdateTags(id, ruleUpdateTagsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule
         * @param {number} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFirewallRule(id: number, firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFirewallRule(id, firewallRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RulesApi - factory interface
 * @export
 */
export const RulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RulesApiFp(configuration)
    return {
        /**
         * Create a firewall rule.
         * @summary Create firewall rule
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRule(firewallRulesRequest?: FirewallRulesRequest, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.createFirewallRule(firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRule(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFirewallRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRule(id: number, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.getFirewallRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRules(page?: number, perPage?: number, options?: any): AxiosPromise<Array<FirewallRulesResponse>> {
            return localVarFp.getFirewallRules(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a tag to firewall rule
         * @summary Add a tag to firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleAddTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: any): AxiosPromise<void> {
            return localVarFp.ruleAddTag(id, ruleAddTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a tag from firewall rule
         * @summary Remove a tag from firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleDeleteTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: any): AxiosPromise<void> {
            return localVarFp.ruleDeleteTag(id, ruleAddTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update tags in firewall rule
         * @summary Update tags in firewall rule
         * @param {string} id 
         * @param {RuleUpdateTagsRequest} [ruleUpdateTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleUpdateTags(id: string, ruleUpdateTagsRequest?: RuleUpdateTagsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.ruleUpdateTags(id, ruleUpdateTagsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule
         * @param {number} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRule(id: number, firewallRulesRequest?: FirewallRulesRequest, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.updateFirewallRule(id, firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RulesApi - object-oriented interface
 * @export
 * @class RulesApi
 * @extends {BaseAPI}
 */
export class RulesApi extends BaseAPI {
    /**
     * Create a firewall rule.
     * @summary Create firewall rule
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public createFirewallRule(firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).createFirewallRule(firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a firewall rule.
     * @summary Delete firewall rule
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public deleteFirewallRule(id: number, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).deleteFirewallRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a firewall rule.
     * @summary Get firewall rule
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public getFirewallRule(id: number, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).getFirewallRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of firewall rules.
     * @summary Get firewall rules
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public getFirewallRules(page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).getFirewallRules(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a tag to firewall rule
     * @summary Add a tag to firewall rule
     * @param {string} id 
     * @param {RuleAddTagRequest} [ruleAddTagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public ruleAddTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).ruleAddTag(id, ruleAddTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a tag from firewall rule
     * @summary Remove a tag from firewall rule
     * @param {string} id 
     * @param {RuleAddTagRequest} [ruleAddTagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public ruleDeleteTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).ruleDeleteTag(id, ruleAddTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update tags in firewall rule
     * @summary Update tags in firewall rule
     * @param {string} id 
     * @param {RuleUpdateTagsRequest} [ruleUpdateTagsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public ruleUpdateTags(id: string, ruleUpdateTagsRequest?: RuleUpdateTagsRequest, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).ruleUpdateTags(id, ruleUpdateTagsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a firewall rule.
     * @summary Update firewall rule
     * @param {number} id 
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public updateFirewallRule(id: number, firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).updateFirewallRule(id, firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SessionsApi - axios parameter creator
 * @export
 */
export const SessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Close a session.
         * @summary Close session
         * @param {string} uid 
         * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clsoeSession: async (uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('clsoeSession', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}/close`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clsoeSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a session.
         * @summary Get session
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getSession', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get session recorded data.
         * @summary Get session recorded data
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionData: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getSessionData', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}/play`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get status from if `session record` feature is enable.
         * @summary Get session record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionRecord: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/security`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list sessions.
         * @summary Get sessions
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions: async (page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Record data about session session.
         * @summary Record session
         * @param {string} uid 
         * @param {RecordSessionRequest} [recordSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordSession: async (uid: string, recordSessionRequest?: RecordSessionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('recordSession', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}/record`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recordSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatus: async (uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('setSessionAuthenticationStatus', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionAuthenticationStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionRecord: async (tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('setSessionRecord', 'tenant', tenant)
            const localVarPath = `/api/users/security/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionRecordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionsApi - functional programming interface
 * @export
 */
export const SessionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Close a session.
         * @summary Close session
         * @param {string} uid 
         * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clsoeSession(uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clsoeSession(uid, clsoeSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a session.
         * @summary Get session
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSession(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSession(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get session recorded data.
         * @summary Get session recorded data
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionData(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RecordedSessionResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionData(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get status from if `session record` feature is enable.
         * @summary Get session record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionRecord(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionRecord(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list sessions.
         * @summary Get sessions
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessions(page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Session>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessions(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Record data about session session.
         * @summary Record session
         * @param {string} uid 
         * @param {RecordSessionRequest} [recordSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordSession(uid: string, recordSessionRequest?: RecordSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordSession(uid, recordSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionAuthenticationStatus(uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionAuthenticationStatus(uid, setSessionAuthenticationStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionRecord(tenant, setSessionRecordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SessionsApi - factory interface
 * @export
 */
export const SessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionsApiFp(configuration)
    return {
        /**
         * Close a session.
         * @summary Close session
         * @param {string} uid 
         * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clsoeSession(uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options?: any): AxiosPromise<void> {
            return localVarFp.clsoeSession(uid, clsoeSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a session.
         * @summary Get session
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(uid: string, options?: any): AxiosPromise<Session> {
            return localVarFp.getSession(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get session recorded data.
         * @summary Get session recorded data
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionData(uid: string, options?: any): AxiosPromise<Array<RecordedSessionResponseInner>> {
            return localVarFp.getSessionData(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get status from if `session record` feature is enable.
         * @summary Get session record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionRecord(options?: any): AxiosPromise<boolean> {
            return localVarFp.getSessionRecord(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list sessions.
         * @summary Get sessions
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions(page?: number, perPage?: number, options?: any): AxiosPromise<Array<Session>> {
            return localVarFp.getSessions(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Record data about session session.
         * @summary Record session
         * @param {string} uid 
         * @param {RecordSessionRequest} [recordSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordSession(uid: string, recordSessionRequest?: RecordSessionRequest, options?: any): AxiosPromise<void> {
            return localVarFp.recordSession(uid, recordSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatus(uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setSessionAuthenticationStatus(uid, setSessionAuthenticationStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setSessionRecord(tenant, setSessionRecordRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionsApi - object-oriented interface
 * @export
 * @class SessionsApi
 * @extends {BaseAPI}
 */
export class SessionsApi extends BaseAPI {
    /**
     * Close a session.
     * @summary Close session
     * @param {string} uid 
     * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public clsoeSession(uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).clsoeSession(uid, clsoeSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a session.
     * @summary Get session
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getSession(uid: string, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSession(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get session recorded data.
     * @summary Get session recorded data
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getSessionData(uid: string, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSessionData(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get status from if `session record` feature is enable.
     * @summary Get session record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getSessionRecord(options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSessionRecord(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list sessions.
     * @summary Get sessions
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getSessions(page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSessions(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Record data about session session.
     * @summary Record session
     * @param {string} uid 
     * @param {RecordSessionRequest} [recordSessionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public recordSession(uid: string, recordSessionRequest?: RecordSessionRequest, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).recordSession(uid, recordSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set session authentication status.
     * @summary Set session authentication status
     * @param {string} uid 
     * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public setSessionAuthenticationStatus(uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).setSessionAuthenticationStatus(uid, setSessionAuthenticationStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Define if sessions will be recorded.
     * @summary Set session record
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).setSessionRecord(tenant, setSessionRecordRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SshApi - axios parameter creator
 * @export
 */
export const SshApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a tag to a public key.
         * @summary Add tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTagPublicKey: async (fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('addTagPublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}/tags`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addTagPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new public key.
         * @summary Create public key
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKey: async (publicKeyRequest?: PublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sshkeys/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a public key.
         * @summary Delete public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicKey: async (fingerprint: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('deletePublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys
         * @param {string} [filter] Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;confirmed&#x60; where the value is &#x60;eq&#x60; to &#x60;true&#x60;.   This is a example to filter and get only the confirmed users. &#x60;&#x60;&#x60;json  [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: true       }   } ]  &#x60;&#x60;&#x60;    So, the output enconded string will result on:     &#x60;&#x60;&#x60;WwogICAgewogICAgInR5cGUiOiAicHJvcGVydHkiLAogICAgInBhcmFtcyI6IHsKICAgICAgICAibmFtZSI6ICJjb25maXJtZWQiLAogICAgICAgICJvcGVyYXRvciI6ICJlcSIsCiAgICAgICAgInZhbHVlIjogdHJ1ZQogICAgICAgIH0KICAgIH0KXQ&#x3D;&#x3D;&#x60;&#x60;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeys: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sshkeys/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a tag from public key.
         * @summary Remove tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTagPublicKey: async (fingerprint: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('removeTagPublicKey', 'fingerprint', fingerprint)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('removeTagPublicKey', 'tag', tag)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}/tags/{tag}`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set a SSH public key.
         * @summary Set SSH key
         * @param {SetSSHKeyRequest} [setSSHKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSSHKey: async (setSSHKeyRequest?: SetSSHKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/ssh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSSHKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a public key.
         * @summary Update public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicKey: async (fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('updatePublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update all tags in a public key.
         * @summary Update tags public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsPublicKey: async (fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('updateTagsPublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}/tags`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagsPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SshApi - functional programming interface
 * @export
 */
export const SshApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SshApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a tag to a public key.
         * @summary Add tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTagPublicKey(fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTagPublicKey(fingerprint, addTagPublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new public key.
         * @summary Create public key
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPublicKey(publicKeyRequest?: PublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePublicKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPublicKey(publicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a public key.
         * @summary Delete public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePublicKey(fingerprint: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePublicKey(fingerprint, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys
         * @param {string} [filter] Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;confirmed&#x60; where the value is &#x60;eq&#x60; to &#x60;true&#x60;.   This is a example to filter and get only the confirmed users. &#x60;&#x60;&#x60;json  [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: true       }   } ]  &#x60;&#x60;&#x60;    So, the output enconded string will result on:     &#x60;&#x60;&#x60;WwogICAgewogICAgInR5cGUiOiAicHJvcGVydHkiLAogICAgInBhcmFtcyI6IHsKICAgICAgICAibmFtZSI6ICJjb25maXJtZWQiLAogICAgICAgICJvcGVyYXRvciI6ICJlcSIsCiAgICAgICAgInZhbHVlIjogdHJ1ZQogICAgICAgIH0KICAgIH0KXQ&#x3D;&#x3D;&#x60;&#x60;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKeys(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PublicKeyResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKeys(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a tag from public key.
         * @summary Remove tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTagPublicKey(fingerprint: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTagPublicKey(fingerprint, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set a SSH public key.
         * @summary Set SSH key
         * @param {SetSSHKeyRequest} [setSSHKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSSHKey(setSSHKeyRequest?: SetSSHKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetSSHKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSSHKey(setSSHKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a public key.
         * @summary Update public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePublicKey(fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePublicKey(fingerprint, updatePublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update all tags in a public key.
         * @summary Update tags public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTagsPublicKey(fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTagsPublicKey(fingerprint, updateTagsPublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SshApi - factory interface
 * @export
 */
export const SshApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SshApiFp(configuration)
    return {
        /**
         * Add a tag to a public key.
         * @summary Add tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTagPublicKey(fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options?: any): AxiosPromise<void> {
            return localVarFp.addTagPublicKey(fingerprint, addTagPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new public key.
         * @summary Create public key
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKey(publicKeyRequest?: PublicKeyRequest, options?: any): AxiosPromise<CreatePublicKey200Response> {
            return localVarFp.createPublicKey(publicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a public key.
         * @summary Delete public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicKey(fingerprint: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePublicKey(fingerprint, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys
         * @param {string} [filter] Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;confirmed&#x60; where the value is &#x60;eq&#x60; to &#x60;true&#x60;.   This is a example to filter and get only the confirmed users. &#x60;&#x60;&#x60;json  [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: true       }   } ]  &#x60;&#x60;&#x60;    So, the output enconded string will result on:     &#x60;&#x60;&#x60;WwogICAgewogICAgInR5cGUiOiAicHJvcGVydHkiLAogICAgInBhcmFtcyI6IHsKICAgICAgICAibmFtZSI6ICJjb25maXJtZWQiLAogICAgICAgICJvcGVyYXRvciI6ICJlcSIsCiAgICAgICAgInZhbHVlIjogdHJ1ZQogICAgICAgIH0KICAgIH0KXQ&#x3D;&#x3D;&#x60;&#x60;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeys(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<Array<PublicKeyResponse>> {
            return localVarFp.getPublicKeys(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a tag from public key.
         * @summary Remove tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTagPublicKey(fingerprint: string, tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeTagPublicKey(fingerprint, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Set a SSH public key.
         * @summary Set SSH key
         * @param {SetSSHKeyRequest} [setSSHKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSSHKey(setSSHKeyRequest?: SetSSHKeyRequest, options?: any): AxiosPromise<SetSSHKey200Response> {
            return localVarFp.setSSHKey(setSSHKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a public key.
         * @summary Update public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicKey(fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options?: any): AxiosPromise<PublicKeyResponse> {
            return localVarFp.updatePublicKey(fingerprint, updatePublicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update all tags in a public key.
         * @summary Update tags public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsPublicKey(fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateTagsPublicKey(fingerprint, updateTagsPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SshApi - object-oriented interface
 * @export
 * @class SshApi
 * @extends {BaseAPI}
 */
export class SshApi extends BaseAPI {
    /**
     * Add a tag to a public key.
     * @summary Add tag public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public addTagPublicKey(fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).addTagPublicKey(fingerprint, addTagPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new public key.
     * @summary Create public key
     * @param {PublicKeyRequest} [publicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public createPublicKey(publicKeyRequest?: PublicKeyRequest, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).createPublicKey(publicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a public key.
     * @summary Delete public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public deletePublicKey(fingerprint: string, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).deletePublicKey(fingerprint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list from all public keys.
     * @summary Get public keys
     * @param {string} [filter] Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;confirmed&#x60; where the value is &#x60;eq&#x60; to &#x60;true&#x60;.   This is a example to filter and get only the confirmed users. &#x60;&#x60;&#x60;json  [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: true       }   } ]  &#x60;&#x60;&#x60;    So, the output enconded string will result on:     &#x60;&#x60;&#x60;WwogICAgewogICAgInR5cGUiOiAicHJvcGVydHkiLAogICAgInBhcmFtcyI6IHsKICAgICAgICAibmFtZSI6ICJjb25maXJtZWQiLAogICAgICAgICJvcGVyYXRvciI6ICJlcSIsCiAgICAgICAgInZhbHVlIjogdHJ1ZQogICAgICAgIH0KICAgIH0KXQ&#x3D;&#x3D;&#x60;&#x60;&#x60; 
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public getPublicKeys(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).getPublicKeys(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a tag from public key.
     * @summary Remove tag public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {string} tag Tag\&#39;s name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public removeTagPublicKey(fingerprint: string, tag: string, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).removeTagPublicKey(fingerprint, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set a SSH public key.
     * @summary Set SSH key
     * @param {SetSSHKeyRequest} [setSSHKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public setSSHKey(setSSHKeyRequest?: SetSSHKeyRequest, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).setSSHKey(setSSHKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a public key.
     * @summary Update public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public updatePublicKey(fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).updatePublicKey(fingerprint, updatePublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update all tags in a public key.
     * @summary Update tags public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public updateTagsPublicKey(fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).updateTagsPublicKey(fingerprint, updateTagsPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a tag to a public key.
         * @summary Add tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTagPublicKey: async (fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('addTagPublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}/tags`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addTagPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceTag: async (uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('createDeviceTag', 'uid', uid)
            const localVarPath = `/api/devices/{uid}/tags`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDeviceTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a tag from device.
         * @summary Delete a tag from device
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceTag: async (uid: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteDeviceTag', 'uid', uid)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('deleteDeviceTag', 'tag', tag)
            const localVarPath = `/api/devices/{uid}/tags/{tag}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a tag name.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: async (tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('deleteTag', 'tag', tag)
            const localVarPath = `/api/tags/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a tag from public key.
         * @summary Remove tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTagPublicKey: async (fingerprint: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('removeTagPublicKey', 'fingerprint', fingerprint)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('removeTagPublicKey', 'tag', tag)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}/tags/{tag}`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rename a tag name.
         * @param {string} tag Tag\&#39;s name.
         * @param {RenameTagRequest} [renameTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameTag: async (tag: string, renameTagRequest?: RenameTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('renameTag', 'tag', tag)
            const localVarPath = `/api/tags/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(renameTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update tags to device
         * @summary Update tags to device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsDevice: async (uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateTagsDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}/tags`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagsDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update all tags in a public key.
         * @summary Update tags public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsPublicKey: async (fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('updateTagsPublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}/tags`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagsPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a tag to a public key.
         * @summary Add tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTagPublicKey(fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTagPublicKey(fingerprint, addTagPublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeviceTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeviceTag(uid, createDeviceTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a tag from device.
         * @summary Delete a tag from device
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeviceTag(uid: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeviceTag(uid, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a tag name.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTag(tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTags(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTags(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a tag from public key.
         * @summary Remove tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTagPublicKey(fingerprint: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTagPublicKey(fingerprint, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Rename a tag name.
         * @param {string} tag Tag\&#39;s name.
         * @param {RenameTagRequest} [renameTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renameTag(tag: string, renameTagRequest?: RenameTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renameTag(tag, renameTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update tags to device
         * @summary Update tags to device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTagsDevice(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTagsDevice(uid, updateTagsDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update all tags in a public key.
         * @summary Update tags public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTagsPublicKey(fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTagsPublicKey(fingerprint, updateTagsPublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * Add a tag to a public key.
         * @summary Add tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTagPublicKey(fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options?: any): AxiosPromise<void> {
            return localVarFp.addTagPublicKey(fingerprint, addTagPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createDeviceTag(uid, createDeviceTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a tag from device.
         * @summary Delete a tag from device
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceTag(uid: string, tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDeviceTag(uid, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a tag name.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTag(tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getTags(options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a tag from public key.
         * @summary Remove tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTagPublicKey(fingerprint: string, tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeTagPublicKey(fingerprint, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rename a tag name.
         * @param {string} tag Tag\&#39;s name.
         * @param {RenameTagRequest} [renameTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameTag(tag: string, renameTagRequest?: RenameTagRequest, options?: any): AxiosPromise<void> {
            return localVarFp.renameTag(tag, renameTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update tags to device
         * @summary Update tags to device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsDevice(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateTagsDevice(uid, updateTagsDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update all tags in a public key.
         * @summary Update tags public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsPublicKey(fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateTagsPublicKey(fingerprint, updateTagsPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * Add a tag to a public key.
     * @summary Add tag public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public addTagPublicKey(fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).addTagPublicKey(fingerprint, addTagPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a tag
     * @summary Create a tag
     * @param {string} uid Device\&#39;s UID
     * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public createDeviceTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).createDeviceTag(uid, createDeviceTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a tag from device.
     * @summary Delete a tag from device
     * @param {string} uid Device\&#39;s UID
     * @param {string} tag Device\&#39;s tag name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public deleteDeviceTag(uid: string, tag: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).deleteDeviceTag(uid, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a tag name.
     * @param {string} tag Tag\&#39;s name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public deleteTag(tag: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).deleteTag(tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getTags(options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).getTags(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a tag from public key.
     * @summary Remove tag public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {string} tag Tag\&#39;s name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public removeTagPublicKey(fingerprint: string, tag: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).removeTagPublicKey(fingerprint, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rename a tag name.
     * @param {string} tag Tag\&#39;s name.
     * @param {RenameTagRequest} [renameTagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public renameTag(tag: string, renameTagRequest?: RenameTagRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).renameTag(tag, renameTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update tags to device
     * @summary Update tags to device
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public updateTagsDevice(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).updateTagsDevice(uid, updateTagsDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update all tags in a public key.
     * @summary Update tags public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public updateTagsPublicKey(fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).updateTagsPublicKey(fingerprint, updateTagsPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get status from if `session record` feature is enable.
         * @summary Get session record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionRecord: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/security`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a token from its tenant.
         * @summary Get token
         * @param {string} [tenant] Tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken: async (tenant?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/token/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate the activation link for user.
         * @summary Validate activation link
         * @param {string} email User\&#39;s email.
         * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidateAccount: async (email: string, token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('getValidateAccount', 'email', email)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getValidateAccount', 'token', token)
            const localVarPath = `/api/user/validation_account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get data about a user
         * @summary Login
         * @param {Login} [login] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (login?: Login, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(login, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get data about a user
         * @summary Login
         * @param {Login} [login] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login_1: async (login?: Login, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(login, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a recovery email to the user.
         * @summary Recover password
         * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverPassword: async (recoverPasswordRequest?: RecoverPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/recover_password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recoverPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register user
         * @summary Register user
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser: async (user?: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resend confirmation to user.
         * @summary Resend confirmation
         * @param {ResendEmailRequest} [resendEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEmail: async (resendEmailRequest?: ResendEmailRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/resend_email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resendEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionRecord: async (tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('setSessionRecord', 'tenant', tenant)
            const localVarPath = `/api/users/security/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionRecordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user password from a recovery token got from email.
         * @summary Update user password
         * @param {string} uid User\&#39;s UID.
         * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecoverPassword: async (uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateRecoverPassword', 'uid', uid)
            const localVarPath = `/api/user/{uid}/update_password`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRecoverPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user\'s data.
         * @summary Update user data
         * @param {string} id User\&#39;s ID.
         * @param {UpdateUserDataRequest} [updateUserDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserData: async (id: string, updateUserDataRequest?: UpdateUserDataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserData', 'id', id)
            const localVarPath = `/api/users/{id}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update only the user password.
         * @summary Update user password
         * @param {string} [id] User ID
         * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword: async (id?: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/{id}/password`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Get status from if `session record` feature is enable.
         * @summary Get session record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionRecord(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionRecord(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a token from its tenant.
         * @summary Get token
         * @param {string} [tenant] Tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToken(tenant?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToken(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validate the activation link for user.
         * @summary Validate activation link
         * @param {string} email User\&#39;s email.
         * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValidateAccount(email: string, token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getValidateAccount(email, token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get data about a user
         * @summary Login
         * @param {Login} [login] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(login?: Login, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(login, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get data about a user
         * @summary Login
         * @param {Login} [login] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login_1(login?: Login, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login_1(login, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send a recovery email to the user.
         * @summary Recover password
         * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoverPassword(recoverPasswordRequest?: RecoverPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoverPassword(recoverPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register user
         * @summary Register user
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUser(user?: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resend confirmation to user.
         * @summary Resend confirmation
         * @param {ResendEmailRequest} [resendEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendEmail(resendEmailRequest?: ResendEmailRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendEmail(resendEmailRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionRecord(tenant, setSessionRecordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update user password from a recovery token got from email.
         * @summary Update user password
         * @param {string} uid User\&#39;s UID.
         * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecoverPassword(uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecoverPassword(uid, updateRecoverPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update user\'s data.
         * @summary Update user data
         * @param {string} id User\&#39;s ID.
         * @param {UpdateUserDataRequest} [updateUserDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserData(id: string, updateUserDataRequest?: UpdateUserDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserData(id, updateUserDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update only the user password.
         * @summary Update user password
         * @param {string} [id] User ID
         * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPassword(id?: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPassword(id, updateUserPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Get status from if `session record` feature is enable.
         * @summary Get session record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionRecord(options?: any): AxiosPromise<boolean> {
            return localVarFp.getSessionRecord(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a token from its tenant.
         * @summary Get token
         * @param {string} [tenant] Tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(tenant?: string, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.getToken(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Validate the activation link for user.
         * @summary Validate activation link
         * @param {string} email User\&#39;s email.
         * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidateAccount(email: string, token: string, options?: any): AxiosPromise<void> {
            return localVarFp.getValidateAccount(email, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Get data about a user
         * @summary Login
         * @param {Login} [login] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(login?: Login, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.login(login, options).then((request) => request(axios, basePath));
        },
        /**
         * Get data about a user
         * @summary Login
         * @param {Login} [login] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login_1(login?: Login, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.login_1(login, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a recovery email to the user.
         * @summary Recover password
         * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverPassword(recoverPasswordRequest?: RecoverPasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.recoverPassword(recoverPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Register user
         * @summary Register user
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(user?: User, options?: any): AxiosPromise<void> {
            return localVarFp.registerUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         * Resend confirmation to user.
         * @summary Resend confirmation
         * @param {ResendEmailRequest} [resendEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEmail(resendEmailRequest?: ResendEmailRequest, options?: any): AxiosPromise<void> {
            return localVarFp.resendEmail(resendEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setSessionRecord(tenant, setSessionRecordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user password from a recovery token got from email.
         * @summary Update user password
         * @param {string} uid User\&#39;s UID.
         * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecoverPassword(uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateRecoverPassword(uid, updateRecoverPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user\'s data.
         * @summary Update user data
         * @param {string} id User\&#39;s ID.
         * @param {UpdateUserDataRequest} [updateUserDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserData(id: string, updateUserDataRequest?: UpdateUserDataRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserData(id, updateUserDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update only the user password.
         * @summary Update user password
         * @param {string} [id] User ID
         * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword(id?: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserPassword(id, updateUserPasswordRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Get status from if `session record` feature is enable.
     * @summary Get session record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getSessionRecord(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getSessionRecord(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a token from its tenant.
     * @summary Get token
     * @param {string} [tenant] Tenant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getToken(tenant?: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getToken(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate the activation link for user.
     * @summary Validate activation link
     * @param {string} email User\&#39;s email.
     * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getValidateAccount(email: string, token: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getValidateAccount(email, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get data about a user
     * @summary Login
     * @param {Login} [login] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public login(login?: Login, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).login(login, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get data about a user
     * @summary Login
     * @param {Login} [login] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public login_1(login?: Login, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).login_1(login, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a recovery email to the user.
     * @summary Recover password
     * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public recoverPassword(recoverPasswordRequest?: RecoverPasswordRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).recoverPassword(recoverPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register user
     * @summary Register user
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public registerUser(user?: User, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).registerUser(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resend confirmation to user.
     * @summary Resend confirmation
     * @param {ResendEmailRequest} [resendEmailRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public resendEmail(resendEmailRequest?: ResendEmailRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).resendEmail(resendEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Define if sessions will be recorded.
     * @summary Set session record
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).setSessionRecord(tenant, setSessionRecordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user password from a recovery token got from email.
     * @summary Update user password
     * @param {string} uid User\&#39;s UID.
     * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateRecoverPassword(uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateRecoverPassword(uid, updateRecoverPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user\'s data.
     * @summary Update user data
     * @param {string} id User\&#39;s ID.
     * @param {UpdateUserDataRequest} [updateUserDataRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserData(id: string, updateUserDataRequest?: UpdateUserDataRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserData(id, updateUserDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update only the user password.
     * @summary Update user password
     * @param {string} [id] User ID
     * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserPassword(id?: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserPassword(id, updateUserPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


